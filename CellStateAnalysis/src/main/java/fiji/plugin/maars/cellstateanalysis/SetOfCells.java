package fiji.plugin.maars.cellstateanalysis;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Random;

import ij.ImagePlus;
import ij.gui.Roi;
import ij.measure.ResultsTable;
import ij.plugin.frame.RoiManager;

/**
 * Class to manipulate a set of cells which corresponds to cells of one field
 * @author marie
 *
 */
public class SetOfCells {
	
	// tools to get results
	private RoiManager roiManager;
	private Roi[] roiArray;
	private ResultsTable rt;
	
	// Inputs
	private String pathToRois;
	private ImagePlus bfImage;
	private ImagePlus fluoImage;
	private ImagePlus correaltionImage;
	private int direction;
	 //-1 -> cell bounds are black then white
	 // 1 -> cell bounds are white then black
	
	private boolean bfAnalysisOnly;
	private Cell[] cellArray;
	
	// output
	private String pathToSaveResults;
	
	/**
	 * Constructor :
	 * @param bfImage : image containing cells of the set (segmentation was realised on this image)
	 * @param fluoImage : fluorescent image used to find which cell are in a mitotic state
	 * @param correaltionImage : correlation image generated by segmentation process
	 * @param focusSlice : slice number correponding to focus plane in bfImage
	 * @param direction : -1 -> cell bounds are black then white
	 *                     1 -> cell bounds are white then black
	 * @param pathToRois : path allowing to get ROIs generated by segmntation process
	 * @param pathToSaveResults : path indicating where results of analysis should be stored
	 */
	public SetOfCells(ImagePlus bfImage,
			ImagePlus correaltionImage,
			ImagePlus fluoImage,
			int focusSlice,
			int direction,
			String pathToRois,
			String pathToSaveResults) {
		
		try {
			PrintStream ps = new PrintStream(pathToSaveResults+bfImage.getShortTitle()+"_CellStateAnalysis.LOG");
			System.setOut(ps);
			System.setErr(ps);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println("Set of cells with fluorescent image :");
		System.out.println("Get all parameters ...");
		this.bfImage = bfImage;
		this.fluoImage = fluoImage;
		this.correaltionImage = correaltionImage;
		this.pathToRois = pathToRois;
		this.pathToSaveResults = pathToSaveResults;
		this.direction = direction;
		System.out.println("Done");
		System.out.println("create result table");
		rt = new ResultsTable();
		System.out.println("Done");
		
		System.out.println("Get ROIs as array");
		bfAnalysisOnly = false;
		roiArray = getRoisAsArray();
		cellArray = new Cell[roiArray.length];
		
		System.out.println("Initialize Cells in array");
		for(int i = 0; i < roiArray.length; i++){
			cellArray[i] = new Cell(bfImage,  correaltionImage, fluoImage, focusSlice, direction, roiArray[i], rt);
		}
		System.out.println("Done.");
	}

	/**
	 * Constructor :
	 * @param bfImage : image containing cells of the set (segmentation was realised on this image)
	 * @param correaltionImage : correlation image generated by segmentation process
	 * @param focusSlice : slice number correponding to focus plane in bfImage
	 * @param direction : -1 -> cell bounds are black then white
	 *                     1 -> cell bounds are white then black
	 * @param pathToRois : path allowing to get ROIs generated by segmntation process
	 * @param pathToSaveResults : path indicating where results of analysis should be stored 
	 */
	public SetOfCells(ImagePlus bfImage,
			ImagePlus correaltionImage,
			int focusSlice,
			int direction,
			String pathToRois,
			String pathToSaveResults) {
		
		try {
			PrintStream ps = new PrintStream(pathToSaveResults+bfImage.getShortTitle()+"_CellStateAnalysis.LOG");
			System.setOut(ps);
			System.setErr(ps);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println("Set of cells without fluorescent image :");
		System.out.println("Get all parameters ...");
		this.bfImage = bfImage;
		this.correaltionImage = correaltionImage;
		this.pathToRois = pathToRois;
		this.pathToSaveResults = pathToSaveResults;
		this.direction = direction;
		System.out.println("Done");
		System.out.println("create result table");
		rt = new ResultsTable();
		System.out.println("Done");
		
		System.out.println("Get ROIs as array");
		bfAnalysisOnly = true;
		roiArray = getRoisAsArray();
		cellArray = new Cell[roiArray.length];
		
		
		//roiManager.runCommand("Delete");
		System.out.println("Initialize Cells in array");
		for(int i = 0; i < roiArray.length; i++){
			cellArray[i] = new Cell(bfImage, correaltionImage,  focusSlice, direction , roiArray[i], rt);
			
			// just for test
			//roiManager.addRoi(cellArray[i].getLinearRoi());
		}
		System.out.println("Done.");
	}
	
	/**
	 * Constructor :
	 * @param cellArray : array of cell
	 */
	public SetOfCells(Cell[] cellArray){
		this.cellArray = cellArray;
	}
	
	/**
	 * Method to shuffle set of cell (put them in random order)
	 */
	public void shuffle() {
		
		int n = length();
		Random random = new Random();
		
		for(int i = 0; i < n; i++) {
			int newPosition = i + random.nextInt(n - i);
			Cell cellTemp = cellArray[i];
			cellArray[i] = cellArray[newPosition];
			cellArray[newPosition] = cellTemp;
		}
	}
	
	/**
	 * Method to open ROI file and get them as ROI array
	 * @return
	 */
	public Roi[] getRoisAsArray() {

		roiManager = new RoiManager();
		roiManager.runCommand("Open", pathToRois);
		return roiManager.getRoisAsArray();
	}
	
	/**
	 * Method to add one of the ROI to RoiManager
	 * @param cellIndex : index of ROI the user want to add to the manager
	 * @param roiType : type of ROI to add, must be "cellLinearROI" for linear ROI and "cellShapeROI" for non-linear ones
	 */
	public void addRoiToManager(int cellIndex, String roiType) {
		if (roiType == "cellShapeROI") {
			roiManager.addRoi(cellArray[cellIndex].getCellShapeRoi());
		}
		else {
			if (roiType == "cellLinearROI") {
				roiManager.addRoi(cellArray[cellIndex].getLinearRoi());
			}
			else {
				System.out.println("Not an option");
			}
		}
	}
	
	/**
	 * Closes RoiManager
	 */
	public void closeRoiManager() {
		roiManager.close();
	}
	
	/**
	 * Method to get Cell corresponding to index
	 * @param index
	 * @return Cell corresponding to index
	 */
	public Cell getCell(int index) {
		return cellArray[index];
	}
	
	/**
	 * Method to get Cell index using coordinates of centroid
	 * @param xCentroid
	 * @param yCentroid
	 * @return index of cell if there is any, -1 otherwise
	 */
	public int getCellIndex(double xCentroid, double yCentroid) {
		int index = -1;
		
		for (int i = 0; i < cellArray.length; i++) {
			if (cellArray[i].getMeasures().getXCentroid() == xCentroid && cellArray[i].getMeasures().getYCentroid() == yCentroid) {
				index = i;
			}
		}
		return index;
	}
	
	/**
	 * 
	 * @return image used for segmentation
	 */
	public ImagePlus getBFImage() {
		return bfImage;
	}
	
	/**
	 * 
	 * @return array length
	 */
	public int length() {
		return cellArray.length;
	}
	
	/**
	 * 
	 * @return path where results are stored
	 */
	public String getPath() {
		return pathToSaveResults;
	}
}
